<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-KK94CHFLLe+nY2dmCWGMq91rCGa5gtU4mk92HdvYe+M/SXH301p5ILy+dN9+nJOZ" crossorigin="anonymous">

    <link rel="stylesheet" href="css/style.css">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">

    <title>Sailesh Portfolio</title>
</head>
<body>
    
  <nav class="navbar navbar-expand-lg navbar-light bg-light">
    <div class="container-fluid">
      <a class="navbar-brand" href="index.html">Sailesh Portfolio</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNavDropdown" aria-controls="navbarNavDropdown" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse justify-content-end" id="navbarNavDropdown">
        <ul class="navbar-nav">
          <li class="nav-item">
            <a class="nav-link" href="index.html">Home</a>
          </li>
          <li class="nav-item dropdown active">
            <a class="nav-link dropdown-toggle" href="#" id="navbarDropdownMenuLink" role="button" data-bs-toggle="dropdown" aria-expanded="false">
              Tutorials
            </a>
            <ul class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
              <li><a class="dropdown-item" href="oop.html">OOP & Inheritance</a></li>
              <li><a class="dropdown-item" href="arrays.html">Arrays</a></li>
              <li><a class="dropdown-item" href="arraylists.html">ArrayLists</a></li>
              <li><a class="dropdown-item" href="searchsort.html">Searching & Sorting</a></li>
              <li><a class="dropdown-item" href="recursion.html">Recursion</a></li>
              <li><a class="dropdown-item" href="bibliography.html">Bibliography</a></li>
            </ul>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="projects.html">Projects</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="culminating.html">Culminating</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="about.html">About Me</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  

  <div class="container">
    <div class="table-of-contents">
      <h2>Table of Contents</h2>
      <ul>
        <li><a href="#searching">Searching</a></li>
        <li><a href="#sorting">Sorting</a></li>
        <li><a href="#common-mistakes">Common Mistakes</a></li>
      </ul>
    </div>

    <div class="content">
      <h1 id="searching">Searching</h1>
      <p>In Java searching refers to the process of finding a specific element within a collection of data such as an array or ArrayList. There are different searching algorithms available, however the most common ones are <strong>sequential search</strong> and <strong>binary search</strong>. The main purpose of using seraching algorithm is to locate the position of a particular element. For example, imagine you are a teacher and you are taking attendance, you go through the attendance list to check if anyone is absent. In this scenario you are <strong>searching</strong> for a specific student to make sure they are present.</p>
    </div>

    <div class="content">
      <h2 id="sequential-search">Sequential Search</h2>
      <p>Sequential search, also known as linear search, is a simple algorithm that checks each element in a collection one by one until the target element is found or the end of the collection is reached. It cane be used with both sorted and unsorted collections of data.<br><br>Here is an example of sequential search on an Integer ArrayList:</p>
    </div>
    <div class="code-box">
      <div class="code-header">
        <div class="code-language">JAVA</div>
        <button class="copy-code" onclick="copyCode(this)">Copy</button>
      </div>
      <pre class="code">
  public static int sequentialSearch(ArrayList<Integer> list, int target) {
    for (int i = 0; i &lt list.size(); i++) {
        if (list.get(i) == target) {
            return i; // Return the index of the found element
        }
    }
    return -1; // Return -1 if the element is not found
  }
      </pre>
    </div>
    <div class="content">
      <p>The time complexity of the search algorithm is O(n), where n is the number of elements in the collection being searched in. The best case scenario for sequential search is O(1), which means the search operation can be completed in constant time as if it is the first element in the array. Since, this search algorithm has to loop through the entire array in order to check for the target element, it becomes inefficient with larger amount of data.</p>
    </div>

    <div class="content">
      <h2 id="binary-search">Binary Search</h2>
      <img src="https://media.geeksforgeeks.org/wp-content/uploads/20220309171621/BinarySearch.png">
      <p>Binary search is a fast search algorithm that <strong>requires</strong> the collection to be sorted in ascending order. It works by repeatedly dividing the search space in half until the target element is found or it runs out of divisions. This is a very efficient searching algorithm for large data sets that are already sorted.<br><br>Here is an example of sequential search on an Integer ArrayList:</p>
    </div>
    <div class="code-box">
      <div class="code-header">
        <div class="code-language">JAVA</div>
        <button class="copy-code" onclick="copyCode(this)">Copy</button>
      </div>
      <pre class="code">
  public static int binarySearch(ArrayList<Integer> list, int target) {
    int left = 0;
    int right = list.size() - 1;

    while (left &lt= right) {
        int mid = left + (right - left) / 2;
        if (list.get(mid) == target) {
            return mid; // Return the index of the found element
        } else if (list.get(mid) &lt target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Return -1 if the element is not found
  }
      
      </pre>
    </div>
    <div class="content">
      <p>The time complexity of the binary search algorithm is O(log n), where n is the number of elements in the collection being searched in. However, the search only works when the entire array is sorted. The best case scenario for binary search is O(1), which means the search operation can be completed in constant time as if it the element is exactly in the middle of the array it only takes one search. This algorithm is great for large sorted data sets due to its efficient approach</p>
    </div>

    <div class="content">
      <h1 id="sorting">Sorting</h1>
      <p>In Java, sorting refers to arranging elements of a collection or array in a specific order. In most scenarios the sorting algorithm sorts the data in either ascending or descending order to make it more organized. The elements are rearranged in a specific order according to a comparison function as it defines the criteria for determining the order of elements. For example, when sorting a list of numbers, the comparison function might specify that the elements should be arranged in ascending order (from the smallest to the largest) or descending order (from the largest to the smallest). There are many different sorting algorithms, and they all have different implementations and run times, and are good for different scenarios. </p>
    </div>

    <div class="content">
      <h2 id="bubble-sort">Bubble Sort</h2>
      <p>
        Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in the wrong order. The process is repeated until the list is sorted. This is usually not recommened for large data sets as the time complexity is quite high.
      </p>
    </div>

    <div class="code-box">
      <div class="code-header">
        <div class="code-language">JAVA</div>
        <button class="copy-code" onclick="copyCode(this)">Copy</button>
      </div>
      <pre class="code">
  public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i &lt n - 1; i++) {
        for (int j = 0; j &lt n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
  } 
      </pre>
    </div>


    <div class="content">
      <p>In the above code, it iterates through the array and compares the adjacent elements. If they are in the wrong order it swaps them, and this process is continued until it is sorted. Bubble Sort has a time complexity of O(n^2) in the average and worst case scenarios. Bubble Sort also has a space complexity of O(1) since it operates directly on the input array. Therefore it is not the most efficient sorting algorithm, but is one of the most intuitive.</p>
      <h2 id="insertion-sort">Insertion Sort</h2>
      <p>
        Insertion Sort is another simple sorting algorithm. It keeps building the final sorted array by continuously inserting elements into their proper position within the sorted part of the array. This means that the sort keeps looking for the right position of that element in the array and inserts it into there.
      </p>
    </div>

    <div class="code-box">
      <div class="code-header">
        <div class="code-language">JAVA</div>
        <button class="copy-code" onclick="copyCode(this)">Copy</button>
      </div>
      <pre class="code">
  public static void insertionSort(int[] arr) {
    int n = arr.length;
    for (int i = 1; i &lt n; ++i) {
        int key = arr[i];
        int j = i - 1;

        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j = j - 1;
        }
        arr[j + 1] = key;
    }
  }
  
      </pre>
    </div>

    <div class="content">
      <p>
        It iterates through the array, starting from the second element, and compares it with the sorted part of the array (elements before the index). If the current element is smaller, it shifts the elements of the sorted part to the right to make space for the current element. This process continues until the entire array is sorted. Insertion Sort has a time complexity of O(n^2) in the average and worst case scenarios. Insertion Sort also has a space complexity of O(1) since it operates directly on the input array.
      </p>
      <h2 id="merge-sort">Merge Sort</h2>
      <p>
        Merge Sort is a divide-and-conquer sorting algorithm. It works by dividing the unsorted array into smaller subarrays, sorting them, and then merging them back to produce a sorted array. This works on the concept that all arrays that are split are sorted, therefore as you continue to merge, the arrays become sorted.
      </p>
    </div>

    <div class="code-box">
      <div class="code-header">
        <div class="code-language">JAVA</div>
        <button class="copy-code" onclick="copyCode(this)">Copy</button>
      </div>
      <pre class="code">

  public static void mergeSort(int[] arr, int left, int right) {
    if (left &lt right) {
        int mid = (left + right) / 2;

        // Sort the left and right halves recursively
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        // Merge the sorted halves
        merge(arr, left, mid, right);
    }
  }

  public static void merge(int[] arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary arrays
    int[] leftArray = new int[n1];
    int[] rightArray = new int[n2];

    // Copy data to temporary arrays
    System.arraycopy(arr, left, leftArray, 0, n1);
    System.arraycopy(arr, mid + 1, rightArray, 0, n2);

    // Merge the temporary arrays
    int i = 0, j = 0, k = left;
    while (i &lt n1 && j &lt n2) {
        if (leftArray[i] &lt= rightArray[j]) {
            arr[k] = leftArray[i];
            i++;
        } else {
            arr[k] = rightArray[j];
            j++;
        }
        k++;
    }

    // Copy remaining elements of leftArray, if any
    while (i &lt n1) {
        arr[k] = leftArray[i];
        i++;
        k++;
    }

    // Copy remaining elements of rightArray, if any
    while (j &lt n2) {
        arr[k] = rightArray[j];
        j++;
        k++;
    }
  }
  
      </pre>
    </div>

    <div class="content">
      <p>
        The mergeSort() recursively divides the array into two halves, sorts them using the mergeSort() method, and then merges the sorted halves using the merge() method. The merge() method combines two sorted subarrays into a single sorted array. The way merge() works is by taking the first element of the two halves, and keeps adding the lower element. This way the end array will be in ascending order. Merge Sort has a time complexity of O(n log n) in all scenarios. It is considered an efficient sorting algorithm for large datasets.<br><br>Here is a video made by Myself and Pouya, talking about the merge sort algorithm:
      </p>
    </div>

    <iframe width="560" height="315" src="https://www.youtube.com/embed/Ie5Yluh71Kk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>

    <div class="content">
      <p>
        I demonstrated the three most common sorting algorithms, however there are many more. Here is a table made by HackerEarth that provides some of the other algorithms and their time complexity.
      </p>
      <img src="assets/searchsort.png">
    </div>
    

    <div class="content">
      <h1 id = "common-mistakes">Common Mistakes using Searching and Sorting</h1>
      <p>
        <ul>
          <li>Not handling edge cases. For example in merge sort, it is important to make sure to add left over elements within the two halves of the array. So, make sure to check for all the edge cases.</li>
          <li>Consider the storing stability, as some sorting algorithms are not stable meaning the relative order within the array might be different if the values are the same.</li>
          <li>Make sure to use the algorithm that fits your scenario, as it might be smart to use insertion sort for small data sets, but merge or tim sort for large data sets.</li>
        </ul>
      </p>
    </div>
  </div>


  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ENjdO4Dr2bkBIFxQpeoTz1HIcje39Wm4jDKdf19U8gI4ddQ3GYNS7NTKfAdVQSZe" crossorigin="anonymous"></script>
  <script src="index.js"></script>
  <script>
    var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
    var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
      return new bootstrap.Tooltip(tooltipTriggerEl)
    })
  </script>
</body>
</html>




